import sys
input = sys.stdin.readline

"""
N개의 거울을 모두 정확히 한 번씩 사용했을 때 캐릭터의 최종 위치의 최댓값을 출력

1. 거울을 사용해 캐릭터의 위치를 바꿀 수 있음
2. 거울을 사용하면 위치는 거울 기준 점대칭인 지점으로 이동(현재 위치 a, 거울 위치 b 일때 2b-a로 이동)
"""
def solve():
    # 거울의 수 N (1 <= N <= 200,000), 현재 위치 s ( s  <= | 10**9 |)
    N, s = map(int, input().strip().split())

    # 각 거울의 위치 A[1, .. i, ..N] (A[i] <= | 10**9 |)
    A = sorted(list(map(int, input().strip().split()))) # 배열을 오름차순으로 정렬

    # 전체 배열을 탐색해 구분
    pos = 0
    neg = 0

    l, r = 0, N-1
    while l < r:
        pos += A[r]
        neg += A[l]

        l += 1
        r -= 1

    if N % 2 == 0: # 짝수인 경우 2 x pos - 2 x neg + s
        ans = 2*pos - 2*neg + s
    else: # 홀수인 경우 2 x pos - 2 x neg - s
        pos += A[l]
        ans = 2*pos - 2*neg - s
    
    print(ans)
solve()

"""
현재 위치를 a, 거울의 위치를 b라 할때

- 이동 순서는 현재 위치에 따라 다음 거울을 결정
    if a > 0: -> b < 0
    if a < 0: -> b > 0

- 만약 거울의 위치가 하나의 부호밖에 없다면
    if a > 0: -> 작은숫자
    if a < 0: -> 큰 숫자
----------------------------------------------------------------------
1. 각 거울의 위치가 양의 정수인지, 음의 정수인지에 따라 서로 다른 배열에 분리

2. 두 배열의 길이가 같아졌을때 현재 위치를 기준으로 양수, 음수를 번갈아 수행

4. 만약 하나의 배열을 연속으로 수행해 두 배열의 길이를 맞춰야 한다면 (or 하나밖에 없다면)
    2A[N] - (2A[N-1] - (2A[i] - (... 의 형태
    if N % 2 == 0:
        2A[N] - 2A[N-1] + 2A[N-2] - ... + s
        = 2(A[N] + A[N-2] + A[N-4] + ...) - 2(A[N-1] + A[N-3] + ... ) + s
    
    if N % 2 == 1:
        2A[N] - 2A[N-1] + 2A[N-2] - .... - s
        = 2(A[N] + A[N-2] + A[N-4] + ...) - 2(A[N-1] + A[N-3] + ... ) - s


2A[2] - 2A[1] + 2A[0] - s
2A[3] - 2A[2] + 2A[1] - 2A[0] + s

결국 초기 배열 A에서 어떤 숫자가 나오던지
2(거울들의 위치 1) - 2(거울들의 위치 2) 의 값이 최대가 되어야 함
또한 N이 홀수든 짝수든 pos 배열의 길이가 neg 배열의 길이보다 +1 크거나 같음

5 1
-1 -2 -3 -4 -5
-12 - (- 18) -s
"""