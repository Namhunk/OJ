import sys
input = sys.stdin.readline

"""
(0, 0)에서 (x, y)를 갈 수 있으면 1 없으면 0 출력

크기가 무한대인 평면 위에 원점 (0, 0)에서 (x, y)로 이동(단계는 0부터 시작)
각 단계마다 두 방향 오른쪽(x 증가)과 위(y 증가) 중 하나를 고른 다음 3**k 만큼 이동 k는 단계 번호

(0, 0)에서 (x, y)를 갈 수 있으면 1을 없으면 0을 출력
"""

def solve(x, y):
    # x, y가 원점의 위치인 경우 1 반환
    if (0, 0) == (x, y): return 1

    # 3**k < 1,000,000,000인 모든 숫자 탐색
    arr = []
    i = 0
    while 1:
        if 3**i >= 1_000_000_000: break # 제시된 범위보다 작은 경우만
        arr.append(3**i)
        i += 1

    
    N = len(arr)-1 # 배열의 마지막 인덱스
    k = set()
    for i in range(N, -1, -1): # 최대값부터 역순으로
        # 현재 위치의 숫자가 x, y 보다 작은 경우만
        if x < arr[i] and y < arr[i]: continue

        # x, y 중 더 큰 값에 현재 3**k를 더해줌
        if x > y:
            x = x - arr[i]
            k.add(i)
        else:
            y = y - arr[i]
            k.add(i)
    
    # 모든 3**k를 뺀 x, y의 값이 원점과 같고 k 배열에 연속적인 숫자들이 쓰였는지 확인
    nums = set(i for i in range(len(k))) # 0부터 len(k)-1)까지
    if (x, y) == (0, 0) and  k == nums:
        return 1
    else:
        return 0


# x, y 입력 (0 <= x, y <= 1,000,000,000)
x, y = map(int, input().strip().split())
print(solve(x, y))
    

"""
모든 도착 좌표는 3**k를 더한 형태(k = 0, 1, 2, ...)

3**k 가 1,000,000,000 보다 작은 경우의 숫자들은
[1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 387420489]
총 19개

모든 경우를 탐색해도 충분히 작은 범위로 보임

"""